---
layout: post
title: 공용 스크립트 제작기🎈10 - 로컬라이징 시스템 편
category: devlog
tags: [unity, CoreScript, Retrospective]
image: /assets/img/blog/unity/2025/CoreBanner10.png
description: >
  Unity 프로젝트의 공용으로 사용할 수 있는 스크립트를 제작하면서 어떻게 만들었는지, 어떤 점에 신경썼는지 설명하는 글입니다.
comments: true
---

* this unordered seed list will be replaced by toc as unordered list
{:toc}

요즘 게임 제작에서 다국어 지원은 선택이 아닌 필수가 되어가고 있는데, 매번 번역 CSV를 만들어서 다시 시스템을 제작하고 하기보다는 역시 이것도 만들어두고 쓰자 싶어서 하나 만들게 되었다. 이번에 만든 공용 스크립트는 기존에 만들어두었는 CSV 파서 시스템을 기반으로 한다. 다른 시스템들과 마찬가지로 중앙에서 관리하고, 언어 변경 시 자동으로 UI가 갱신된다.

즉, CSV 파일에서 번역을 관리하고, 컴포넌트를 붙이면 자동으로 텍스트가 갱신되며, 에디터에서도 실시간으로 미리보기할 수 있는 시스템이다. 그리고 언어마다 다른 폰트도 자동으로 적용되어야 해서 그 부분까지 신경썼다.

# 💡예시
게임에 메인 메뉴 버튼이 필요하다고 해보자. 그럴 때 먼저 CSV 파일을 작성한다.

**Assets/Data/CSV/LocalizationData.csv:**
```csv
Key,Korean,English
UI_BTN_START,시작,Start
UI_BTN_OPTIONS,옵션,Options
UI_BTN_QUIT,종료,Quit
UI_SCORE,점수: {0},Score: {0}
```

그 뒤, Unity 에디터에서 `TMP_Text`에 `LocalizedText` 컴포넌트를 추가해주고, Key를 입력하면 끝이다. 그러면 바로 에디터에서 미리보기가 가능하고, 폰트를 설정해두었다면 폰트도 변경된다.

코드에서 직접 조회하는 방법도 있긴 한데 추천은 안한다.
```csharp
string startText = LocalizationManager.Instance.GetText("UI_BTN_START");
```

포맷팅의 경우 다음과 같이 사용한다.
```csharp
public class ScoreUI : MonoBehaviour
{
    [SerializeField] private LocalizedText scoreText;

    public void UpdateScore(int score)
    {
        // "점수: {0}" → "점수: 1000"
        scoreText.SetFormattedText(score);
    }
}
```

언어를 바꾸고 싶을 땐 한 줄이면 된다.
```csharp
LocalizationManager.Instance.SetLanguage(LanguageType.English);
```

# 📊 클래스 다이어그램
이번엔 단순하게 나왔다. 이미 있는 CSV파서 시스템을 사용해서 그럴까.

```
LocalizationManager (싱글톤)
LocalizedText (MonoBehaviour)
LanguageType (Enum)
```

# 📁 시스템 아키텍처
## 핵심 컴포넌트

###### LocalizationManager (싱글톤 매니저)
- 역할: 모든 로컬라이징 데이터의 중앙 관리자
- 주요 기능:
  - 현재 언어 설정 관리 (PlayerPrefs 자동 저장)
  - 시스템 언어 자동 감지
  - 텍스트 조회 (GetText)
  - 포맷팅 지원 (string.Format)
  - 언어별 폰트 제공 (GetCurrentFont)
  - 언어 변경 이벤트 발행 (OnLanguageChanged)
- 초기화:
  - CSVManager.Initialize() 이후에 호출
  - LoadLanguageFromPrefs(): PlayerPrefs에서 저장된 언어 로드
  - BuildLocalizationDictionary(): CSV 데이터를 Dictionary로 캐싱
- 폰트 시스템:
  - Inspector에서 한국어/영어 폰트 설정
  - GetCurrentFont()로 현재 언어에 맞는 폰트 반환

###### LocalizedText (MonoBehaviour 컴포넌트)
- 역할: TMP_Text에 자동으로 번역된 텍스트 표시
- 주요 기능:
  - Key만 설정하면 자동으로 번역 텍스트 표시
  - 언어 변경 시 자동 갱신 (이벤트 구독)
  - 언어별 폰트 자동 적용
  - 에디터 실시간 미리보기 (ExecuteAlways)
  - 포맷팅 지원 (SetFormattedText)  
    : 포맷팅은 당연한 얘기지만 다른 스크립트에서 수동으로 넣어줘야한다.
  - 수동 갱신 (RefreshText)
- 생명주기:
  1. Awake: TMP_Text 컴포넌트 캐싱 및 이벤트 구독  
  2. OnValidate: 에디터에서 Key 변경 시 즉시 갱신  
  3. OnLanguageChanged: 언어 변경 이벤트 수신 → 텍스트 및 폰트 갱신  
  4. OnDestroy: 이벤트 구독 해제

###### LanguageType (Enum)
- 역할: 지원 언어 정의
- 확장:
  - Enum에 언어 추가
  - CSV에 해당 언어 컬럼 추가
  - CSVParser로 LocalizationData 재생성

# 🔄 데이터 흐름

###### 초기화 단계
1. 게임 시작 → CSVManager.Initialize() 호출  
   ↓
2. LocalizationManager.Initialize() 호출  
   ↓
3. \[LoadLanguageFromPrefs] PlayerPrefs에서 언어 로드
   - 저장된 값이 없으면 DetectSystemLanguage() 호출
   - 기타 언어 → LanguageType.English (기본값)  
   ↓
4. \[BuildLocalizationDictionary] CSV 데이터 캐싱
   - CSVManager.GetTable() 호출
   - Dictionary<string, LocalizationData>로 변환
   - 중복 키 검사  
   ↓
5. \[완료] LocalizationManager 사용 가능

###### UI 표시 프로세스 (LocalizedText)
1. LocalizedText 컴포넌트가 GameObject에 추가됨  
   ↓
2. \[Awake] 초기화
   - TMP_Text 컴포넌트 캐싱
   - OnLanguageChanged 이벤트 구독 (런타임만)
   - UpdateText() 호출  
   ↓
3. \[UpdateText] 텍스트 갱신
   - 에디터 모드: GetTextInEditor(key) → CSV 직접 로드
   - 런타임 모드: GetText(key) → Dictionary 조회
   - TMP_Text.text에 적용  
   ↓
4. \[UpdateFont] 폰트 적용
   - GetCurrentFont() → TMP_FontAsset
   - TMP_Text.font에 적용  
   ↓
5. \[완료] UI에 번역된 텍스트 및 폰트 표시

###### 언어 변경 프로세스
1. SetLanguage(LanguageType) 호출  
   ↓
2. \[중복 체크] 같은 언어면 무시
3. \[언어 변경] currentLanguage 업데이트  
   ↓
4. \[PlayerPrefs] 언어 설정 저장
   - PlayerPrefs.SetInt(LANGUAGE_PREFS_KEY, (int)language)
   - PlayerPrefs.Save()  
   ↓
1. \[이벤트 발행] OnLanguageChanged?.Invoke(language)  
   ↓
2. \[구독자 갱신] 모든 LocalizedText 컴포넌트
   - OnLanguageChanged 핸들러 실행
   - UpdateText() → 새 언어의 텍스트로 갱신
   - UpdateFont() → 새 언어의 폰트로 갱신  
   ↓
7. \[완료] 모든 UI가 새 언어로 갱신됨

###### 에디터 미리보기 프로세스
1. Inspector에서 LocalizedText.Key 변경  
   ↓
2. \[OnValidate] Unity가 자동 호출  
   ↓
3. \[UpdateText] 텍스트 갱신
   - GetTextInEditor(key) 호출
   - CSV 파일 동기 로드 (File.ReadAllLines)
   - 헤더 파싱 → Key 및 언어 컬럼 인덱스 찾기
   - 데이터 행 검색 → 해당 Key의 텍스트 반환
   - TMP_Text.text에 적용  
   ↓
4. \[완료] 에디터에서 즉시 미리보기 확인!

# 🎯 신경 쓴 부분

###### 에디터 실시간 미리보기
ExecuteAlways + OnValidate로 에디터에서 즉시 확인
```csharp
[ExecuteAlways]  // 에디터 모드에서도 실행
public class LocalizedText : MonoBehaviour
{
    private void OnValidate()
    {
        // Key 변경 시 즉시 텍스트 업데이트
        if (!Application.isPlaying)
        {
            string text = LocalizationManager.Instance.GetTextInEditor(key);
            this.text.text = text;
        }
    }
}
```
- 코드 수정 없이 Inspector에서 Key만 입력
- 저장하지 않아도 즉시 미리보기
- 번역 오타를 바로 확인 가능

###### 자동 폰트 시스템
언어마다 다른 폰트를 자동으로 적용
```csharp
public TMP_FontAsset GetCurrentFont()
{
    switch (currentLanguage)
    {
        case LanguageType.Korean:
            return koreanFont;
        case LanguageType.English:
            return englishFont;
        default:
            return null;
    }
}
```
- LocalizationManager에 폰트 설정 (Inspector)
- LocalizedText가 자동으로 폰트 적용
- 언어 변경 시 텍스트와 함께 폰트도 갱신
- 별도 코드 작성 불필요

###### 포맷팅 지원
동적 값을 삽입할 수 있는 string.Format 지원
```csharp
// CSV: "점수: {0}"
public string GetText(string key, params object[] args)
{
    string format = GetText(key);
    try
    {
        return string.Format(format, args);
    }
    catch (FormatException e)
    {
        Debug.LogError($"포맷 오류: {key}\n{e.Message}");
        return format;
    }
}
```
- 점수, 레벨, 아이템 개수 등 동적 데이터 표시
- LocalizedText.SetFormattedText()로 간편 사용
- 에러 처리로 안전성 보장

###### 리플렉션 기반 언어 필드 접근
언어 추가 시 코드 수정 불필요
```csharp
// 리플렉션으로 현재 언어에 맞는 필드 값 가져오기
string languageFieldName = currentLanguage.ToString(); // "Korean"
FieldInfo field = typeof(LocalizationData).GetField(languageFieldName);
string text = (string)field.GetValue(data);
```
- LanguageType enum에 언어 추가만 하면 됨
- CSV에 컬럼 추가 → CSVParser 재생성
- GetText() 코드는 수정 불필요
- 확장성 우수
- Dictionary 캐싱으로 완화

---
# 결론
컴포넌트만 붙이면 자동으로 텍스트와 폰트가 갱신되니 편하다. 여기에 욕심 좀 내자면 Text UI의 width/height가 길이에 따라 자동조절되고, 줄바꿈이 자유로웠으면 좋겠다는 점인데 이거는 로컬라이징이랑은 별개니까 다음 기회에 해보는걸로.