---
layout: post
title: 게임용 절차적 크리처 생성 및 애니메이션
category: devlog
tags: [papers, procedural-generation]
image: /assets/img/blog/book/Pasted-image-20240820095207.png
description: >
 2022년 8월 본머스 대학 
comments: true
---

* this unordered seed list will be replaced by toc as unordered list
{:toc}

https://nccastaff.bournemouth.ac.uk/jmacey/MastersProject/MSc22/01/ProceduralCreatureGenerationandAnimationforGames.pdf
PROCEDURAL CREATURE GENERATION AND ANIMATION FOR GAMES
게임용 절차적 크리처 생성 및 애니메이션

스포어와 비슷하다해서 흥미가 동함

https://youtu.be/teYhnpl29P4
아 황당해 귀여워 아 미쳤다

https://www.alanzucconi.com/2017/04/17/procedural-animations/
이것도 꽤 비슷. 이거 읽어도 재밌겠다. 

![](/assets/img/blog/book/Pasted-image-20240820095207.png)

Alex Christo 
Msc Computer Animation and Visual Effects 
Bournemouth University 
20th August 2022

# 개요
이 보고서는 비디오 게임의 크리처를 위한 실시간 절차적 생성 시스템을 설계하고 구현하는 방법을 설명합니다. 
유니티로 구현되고 C#으로 작성된 최종 시스템은 자유형 변형 기법과 자동 리깅을 활용하여 기본 바디를 생성합니다. 그런 다음 새로운 사지 부착 알고리즘이 미리 만들어진 신체 부위를 부착하고 스케일을 조정하여 비행, 수영, 걷기 등 세 가지 크리처 유형 중 하나를 생성합니다. 
각 크리처 유형에는 절차적 정지 및 이동 애니메이션이 있습니다. 특히 걷는 크리처를 위한 절차적 보행 시스템은 크리처의 크기와 속도를 사용하여 자연스럽게 보이는 동작을 생성합니다. 이 프로젝트는 다양한 종류의 무작위 크리처를 실시간으로 성공적으로 생성하며, 모두 상당히 자연스러운 애니메이션을 구현합니다. 각 크리처의 시각적 충실도와 애니메이션의 범위에는 한계가 있지만, 이 프로젝트는 이전보다 더 개방적인 절차적 크리처 생성 시스템을 제공하여 향후 이 분야의 작업에 도움이 될 것으로 기대됩니다.

# 1. Introduction
- 게임디자이너가 수작업으로  콘텐츠를 생성하는 것이 아닌 알고리즘을 통해 게임 내 콘텐츠를 생성 = 절차적 생성
- 우선은 각각 움직임, 정지 및 회전 애니메이션이 있는 낮은 단계부터 크리처를 만드는 것을 목표로 한다(모두 절차적 생성으로 구현)

# 2. Research and Design
## 2-1. Previous Work and Technology
### 2-1-1. 절차적 크리쳐 생성
- Spore(2008)
	- 크리쳐 자체는 절차적생성은 아님.  유저가 만들기 때문에...
	- 애니메이션에서는 차이가 있다. 
	  큰 다리를 가진 생물은 작은 다리를 가진 생물과 같은 속도로 걷지만 걸음걸이의 크기는 훨씬 더 크고 빈도는 적다.
	- 다만 아이디어는 가져올 수 있었다.
		- 기본 몸체에서 시작
		- 이후에 팔다리를 부착
		- 가능한 범위를 제한
		- 팔 다리 크기와 모양이 변경될 때 애니메이션을 절차적으로 조정
- No Mans Sky (2016)
	- 아티스트가 우선 크리쳐를 만들 수 있는 수천 개의 컴포넌트 파트를 만듦
	- 동물 유형이 수백 가지가 있고, 각각 다양한 '변형'을 할 수 있음
		- 각 변형은 같은 리그를 가지고 있음
		- 몸의 각 부분의 크기 조정 가능
		- 머리, 껍질, 날개 등의 부가요소 추가 가능
		- 애니메이션은  스케일과 리그에 따라  맞게 수정됨
	- 방대한 에셋 뱅크 + 사전정의된 동물 유형

- Creature generation using genetic algorithms and auto rigging(2013)
  유전 알고리즘과 자동 리깅을 사용한 크리처 생성
	- 후디니 기반 시스템
	- 애니메이션을 고려하지 않고 순수하게 크리쳐 생성과 리깅만 다룸
	- 기본적으로 리그의 뼈에 해당하는 일련의 세그먼트로부터 크리처를 빌드
	- 기본 몸체 섹션의 크기와 각도를 수정하는 것으로 시작
	- 임의의 수의 다리, 팔, 날개, 손가락 등의 섹션 수를 선택
	- 팔, 다리 및 머리는 본체의 미리 정해진 세그먼트에 부착
	- 세그먼트 단위로 작업하면 자동 리깅이 아주 간단해진다.
	- 다리는 이족보행 및 사족보행 스타일로만 추가 가능
	- 팔은 수에 관계없이 어깨의 같은 지점에 부착
	- 기존 크리처 디자인을 유전알고리즘을  통해 새로운 크리처를 만드는 데에 사용
	- 크리처가 성공 기준에 맞을 때까지 교차 교배를 하여 기괴한 모양의 크리처를 제외시킴
	- 단, 실시간 애플리케이션에는 적합하지 않았다
	- 다만 팔다리의 부착 지점을 지정하는 것은 차용하였다

### 2-1-2. 절차적 애니메이션 생성
- 물리 기반 방식
	- 크리처는 일련의 세그먼트로부터 만들어집니다.
	- 세그먼트는 결합되며, 세그먼트 사이의 지점이 관절점 역할을 합니다. 
	- 여기서 유전 알고리즘은 세그먼트를 결합하여 걷기, 점프 또는 수영과 같은 특정 조건에서 움직일 수 있는 생물을 만드는 데 사용됩니다.
	- 캐릭터가 신체에 물리 작용을 통해 공간을 성공적으로 이동할 수 있도록 일련의 세대에 걸쳐 애니메이션의 파라미터를 조정
	-  이러한 최적화 접근 방식은 여러 세대를 거쳐야 만족스러운 솔루션에 도달할 수 있습니다. 따라서 이러한 접근 방식은 비디오 게임과 같은 실시간 영역에는 적합하지 않습니다.
	- 또한 이러한 방법으로 생성된 애니메이션은 자연스럽지 않은 경우가 많습니다. 이는 크리처가 한 장소에서 다른 장소로 이동하는 성공 기준을 만들기는 쉽지만 '제대로' 보이는지 최적화하기는 훨씬 더 어렵기 때문입니다.
- 신경망
	- 모션 캡처 데이터 또는 직접 제작한 애니메이션을 학습 데이터로 사용하여 매개변수화된 모델을 생성
	- 하지만 존재하지 않는(그리고 팔다리가 몇 개든 있을 수 있는) 생물을 위한 애니메이션을 제작하는 데 초점을 맞추고 있기 때문에 양질의 훈련 데이터에 의존할 수 없었다.
- **인버스 키네마틱 IK(채택)**
	-  물체의 움직임을 유발하는 힘을 고려하지 않고 순전히 물체의 움직임에만 관심이 있음
	- 엔드 이펙터의 원하는 목적지와 조인트 체인의 루트 위치가 주어지면 일련의 조인트의 위치/회전을 계산하는 작업을 처리
		- 예를 들어 다리를 애니메이션할 때 일반적으로 발이 엔드 이펙터가 되고 엉덩이가 루트
		-  발걸음이 어디로 향할지 예측한 다음 캐릭터가 이 예측된 걸음 위치에 얼마나 가까이 있는지에 따라 발 위치를 구동
		- 일반적으로 각 단계를 배치하기 위해 환경에 레이를 투사
		- 계산이 적기 때문에 실시간에 매우 적합하며, 파라미터 중심적 특성으로 인해 즉석에서 조정가능
		-  다리 크기, 속도, 게이트 등이 크리처마다 다르고 이를 애니메이션에 반영하기 위해 간단한 파라미터 세트를 조정할 수 있다는 점에서 절차적 크리처에 적합

## 2-2. Initial Idea
- Spore에서 영감을 얻어 기본 몸체를 생성하는 것이 크리처의 시작점 역할을 하기로 결정.
- 기본 몸체 뼈대에 팔다리를 연결하기 위한 기준점을 조작
- 팔다리는 IK 기반 애니메이션 시스템으로 구동되어, 크리처의 크기와 속도에 따라 필요에 따라 애니메이션을 조정
![](/assets/img/blog/book/Pasted-image-20240820102251.png)
귀엽다.

## 2-3. Requirements

작업명세
- 유니티로 동작할 것
- 모든 크리쳐는 Idle 모션을 가질 것
- 모든 크리쳐는 Forward 이동과 Left, Right 회전을 가질 것
- 크리쳐 생성기는 크리쳐의 사이즈의 다양성을 가질 것
- 크리쳐 생성기는 크리쳐의 스피드의 다양성을 가질 것
- 걷는 애니메이션은 크리쳐의 사이즈와 스피드에 영향을 받을 것
- 크리쳐 생성기는 다양한 이동스타일을 가질 것(걷기, 날기, 수영하기)
- 크리쳐 생성기는 다양한  바디 스타일을 가질 것
- 크리쳐 생성기는 다양한 보행 스타일(이족보행, 사족보행)을 가질 것
- 생성된 크리쳐는 일반적으로 보기에, 손으로 디자인 한 것만큼 설득력이 있어야 할 것
  (앞다리가 작아서 쓰러질 것 같은 크리쳐는 X)
- 크리처 생성에 0.5초 이상 걸리지 않을 것

# 3. Technical Background
## 3-1. Free Form Deformation (FFD) 
FFD란?
메시를 둘러싼 점의 3차원 그리드를 조작하여 오브젝트를 부드럽게 변형하는 데 사용되는 오래된 기법(Sederberg and Parry, 1986)
![](/assets/img/blog/book/Pasted-image-20240821095628.png)
### 3-1-1. 번스타인 다항식 Bernstein Polynomial
3D 그래픽에서 매끄러운 변형을 만드는 데 아주 유용
![](/assets/img/blog/book/Pasted-image-20240821103738.png)
- 로컬  좌표 공간과 벡터
	- 변형할 물체(메쉬)의 정점들은 세 개의 벡터 S, T, U로 정의된 로컬 좌표 공간에 배치
- 점의 위치계산
	- P를 알려면 기준점 P0와 위에서 말한 세 방향으로 얼마나 떨어져 있는지를 계산해야 함
		- P = P0 + Ss + Tt + Uu
	- s, t, u는 각각 S, T, U 방향으로의 상대적인 위치를 나타내는 값
		- s = (T x U) ⋅ (P - P0) / ((T x U) ⋅ S)
		- t = (U x S) ⋅ (P - P0) / ((U x S) ⋅ T)
		- u = (S x T) ⋅ (P - P0) / ((S x T) ⋅ U)
- 제어점
	- 각 방향으로 점을 얼마나 눌렀는지(제어점이 얼마나 기여했는지 계산)
	- 제어점들은 P(i,j,k)로 표현됨
	- 수식의 각 합(Σ)은 각각의 방향(S, T, U)에서 공이 얼마나 변형되었는지 계산하는 역할

## 3-2. rigging/skinning of 3d models
### 3-2-1. Rigging
- 릭은 메시의 스켈레톤 역할
- 릭은 양쪽 끝에 다른 뼈를 연결할 수 있는 '뼈'로 구성됩니다. 
- 뼈 사이의 각 연결은 릭의 관절 지점 역할을 합니다. 
- 본은 연결 지점을 통해 부모 본으로 회전할 수 있으며 모든 자식 본은 그 변형을 따릅니다. 
- 관절에 설정을 추가하여 팔꿈치가 180도 이상 회전하지 못하도록 사실적인 제한을 줄 수 있습니다. 
### 3-2-2. Skinning
- 뼈대를 메시의 버텍스에 매핑하는 프로세스
- 유기적인 캐릭터의 매끄러운 모양을 유지하기 위해 여러 개의 본이 버텍스의 최종 위치에 기여
-  웨이트 페인팅
	- 각 뼈가 메시에서 미치는 영향의 가중치를 지정하는 프로세스
	- 연관된 본 가중치가 없는 버텍스는 변형되지 않음

# 4. Implementation
소스코드: https://github.com/kingkristo

## 4-1. Body Generation
### 4-1-1.  Linear Interpolation
베이스  바디를 생성하는 단계
팔다리의 부착 위치도 필요

베이스 구체 메시를 가져와 각 버텍스를 프로그래밍 방식으로 수정하는 것은 생물체처럼 보이는 바디를 만드는데 너무 복잡하다고 생각했음.
또한 미리 설정된 팔다리 부착 지점이 있는 베이스 바디 세트에서 선택하는 것도 너무 제한적이라고 생각했음.
-> 결국 이 두 가지 방법을 혼합한 하이브리드 방식으로 구현

하나의 캡슐 모양을 기본으로 하여 다양한 동물과 체형에 따라 느슨하게 9개의 기본 바디 세트를 만들었음.
![](/assets/img/blog/book/Pasted-image-20240821104932.png)
이 바디 중 세 개를 무작위로 선택하고 0과 1 사이의 임의 가중치를 사용하여 선형 보간. 
따라서 각 기본 바디의 정점 수가 같아야 하며, 동일한 방식으로 정렬하는 것이 중요했습니다.
![](/assets/img/blog/book/Pasted-image-20240821105011.png)
로우 폴리곤으로 만들면 메시의 모든 버텍스가 검사되는 알고리즘의 모든 부분(예: 러핑 베이스 바디)의 성능이 크게 향상되는 추가적인 이점이 있었음.
하지만 미리 만들어진 팔다리를 추가하자 유니티가 바디에 약간의 스무딩 작업을 수행하여 어색해짐.
![](/assets/img/blog/book/Pasted-image-20240821105219.png)
이 문제를 해결하기 위해 크리처의 각 면마다 셰이딩을 수행하는 셰이더를 구성하여 메시의 각 면에 그라데이션이나 셰이딩 없이 단일 색상이 할당되도록 했음.
셰이더 자체는 단순히 머티리얼 위치를 DDX 및 DDY 부분 파생물로 분할합니다. 최종 페이스 컬러 = ((DDX x DDY) ⋅ ld) * mc, 여기서 ld는 광원 방향이고 mc는 머티리얼 컬러입니다.

### 4-1-2. Free Form Deformation
더 많은 변형을 추가하기 위해 적용.

- 메쉬 주위에 3 x 3 x 11의 제어점 그리드가 구성됨.
- 그리드의 각 3 x 3 “슬라이스”는 x, y 및 z 방향으로 무작위로 스케일링
- 헤엄치는 생물 유형은 걷거나 날아다니는 생물보다 x와 z는 더 작고, 22y 범위의 무작위 값이 더 크도록  설정. (물고기가 육상 동물보다 몸이 평평한 경향이 있기 때문에)

문제발생.
z 차원에서 슬라이스의 크기를 임의로 조정하면 슬라이스의 순서가 자주 어긋나서 몸체가 양쪽 끝이 오목해지는 문제가 발생
![](/assets/img/blog/book/Pasted-image-20240826161838.png)

이 문제를 해결하기 위해 
- 각 슬라이스의 z 차원을 무작위로 스케일링하는 대신 이전 슬라이스의 z 값을 저장
- 여기에 임의의 양을 더하여 현재 슬라이스의 z 위치를 얻음. 
![](/assets/img/blog/book/Pasted-image-20240826161931.png)

### 4-1-3. Auto Rigging and Skinning
- 뼈의 수는 몸체의 크기에 따라 결정. 
- 그런 다음 메시의 “목”과 “꼬리” 정점을 찾습니다
	- 머리 정점과 꼬리 정점은 메쉬 중심의 y 및 x 좌표의 가장 멀리 떨어져 있는 두 정점.
	- 머리 정점은 두 정점 중 z 방향에서 가장 앞쪽에 있는 정점
- 척추
	- 헤엄치는 생물이라면 머리를 Root로하고 꼬리까지 뼈를 추가
	- 걷거나 나는 생물이라면 중심을 Root로 하고 목과 꼬리를 추가
![](/assets/img/blog/book/Pasted-image-20240826164648.png)

- 캡슐 콜라이더가 바디 중앙 임의의 높이에 추가됨
  캡슐의 높이는 크리처가 지상에서 얼마나 높이 올라갈지 결정함
- 뼈와 함께 움직이도록 몸체에 스킨을 입힘
	- 각 버텍스는 가장 가까운 4개의 뼈의 영향을 받음
	- 각 뼈에 할당된 무게는 해당 뼈와 버텍스의 거리에 따라 결정
	- 4개의 뼈가 각 버텍스에 영향을 미치면 변형이 매끄럽고 거친 굴곡이 발생하지 않게 된다.

### 4-1-4. Body Adjustments
스포어를 보면 척추를 흥미로운 모양으로 구부리는 것으로 다양성과 개성을 더함.
물고기는 제외하고 걷거나 날아다니는 생물에게만 적용했다.
- 목이나 꼬리가 100도 이상 회전하지 않도록 적용
- 각 본에 적용했을 때 가장 자연스러운 최대 각도를 찾음 (200/본의 수)
- 꼬리와 목 모두 0과 최대각도 사이에서 두 개의 랜덤값을 적용
- 꼬리와 목 외의 모든 뼈에 각 회전을 적용

머리 조정
- 목 끝에 간단한 구형 머리 추가
- 두 번째 목 뼈의 부착지점 사이의 거리를 기준으로 스케일 조정

몸체 조정
- 몸체의 스케일을 0.5에서 2 사이에서 무작위로 조정
- 이 스케일을 사용하여 초기 이동 속도를 설정
- 이를 다시 임의의 양만큼 수정

## 4-2. Limb Attachment
### 4-2-1. Flying Creatures
- 날개는 '윙윙거리는' 버징 날개와 '펄럭이는' 플래핑 날개 2가지 스타일로 분류
- 다리는 위에 떠있어야 했는데 Two Bone IK를 적용
	- 루트는 고정된 상태로 유지되고, 팁은 타깃을 따라 움직이며, 중간 뼈는 필요에 따라 회전
	  ![](/assets/img/blog/book/Pasted-image-20240826172545.png)

날개를 결정하는 의사 코드

**If "버징" 스타일이라면**
- x, y, z 방향으로 날개를 무작위로 스케일한다.
- 날개를 척추의 앞쪽 절반에 있는 임의의 뼈의 상단 부착 지점에 부착한다. 
  //자연에서는 곤충 날개가 항상 앞쪽 절반에 붙어 있음

**If "플래핑" 스타일이라면**
- 날개를 무작위로 균일하게 스케일한다.
- 날개를 척추의 중간 뼈의 좌우 부착 지점에 부착한다.

**다리 쌍의 수를 1에서 8 사이에서 결정**

**다리가 밀집되어 배치될지 결정**

**If 뼈가 여전히 사지 부착에 사용 가능하다면**
- 다리의 수에 따라 무작위 균일한 다리 크기를 결정한다. 
  //다리 수가 많을수록 크기는 작아지고, 반대의 경우도 마찬가지
- **If "밀집"되어 있다면**
	- 첫 번째 다리 쌍을 척추의 앞쪽 절반에 있는 임의의 뼈의 좌우 부착 지점에 부착한다.
	- Foreach 각각의 추가적인 다리 쌍에 대해
	    - 다른 다리 쌍과의 교차를 피할 수 있는 첫 번째 사용 가능한 뼈에 부착한다.
- **Else**
	- 다리를 몸 길이에 맞춰 균등 간격으로 배치하라.

### 4-2-2. Swimming Creatures
- 꼬리, 가슴 지느러미, 등 지느러미 3가지 유형의 신체 부위를 부착

등 지느러미 무작위 결정
- Foreach 각 등 지느러미에 대해
	- If 기존 등지느러미와 교차하지 않는 뼈를 사용할 수 있는 경우
		- 등 지느러미 스타일 결정
		- 사용가능한 뼈를 무작위 선택, 상단 부착지점에 부착
		- 지느러미 크기를 x, y, z 무작위로 조절

가슴 지느러미의 개수를 무작위로 결정
- Foreach 각 가슴 지느러미에 대해  
	- If 기존 가슴 지느러미와 교차하지 않는 뼈를 사용할 수 있는 경우
		- 가슴 지느러미 스타일 결정
		- 사용가능한 뼈를 무작위 선택, 좌우 부착지점에 부착
		- 지느러미 크기를 x,y,z 무작위 조절

꼬리 결정
- 꼬리 스타일 결정
- 꼬리 뼈 끝에 꼬리 부착
- 꼬리 크기를 x, y, z 무작위 조절


### 4-2-3. Walking Creatures
- 다리와 팔 두가지 신체부위 부착 가능
- 팔다리는 simple two bone IK 사용
- 목표 위치는 이후 절차적 애니메이션 알고리즘에 의해 구동

다리 부착 기준
- 다리가 겹치지 않도록 합니다. 
- 다리가 균형 잡힌 것처럼 보이도록 합니다(예: 생물이 넘어질 것 같지 않게). 
- 실제라면 다리를 지탱할 수 있는 신체 부위(예: 엉덩이와 같이 가장 넓은 부분)에 다리를 부착합니다.
- 재미있는 디자인의 다양한 스타일의 크리처가 있습니다.

왼쪽과 오른쪽 “엉덩이” 연결 지점 사이의 거리를 사용하면 계산을 거의 하지 않고도 메시의 해당 부분에 대한 두께를 매우 쉽게 구할 수 있었다.

엉덩이 너비를 기준으로 가장 큰 거리와 작은 거리를 찾는 의사코드
- **If 몸 길이가 지면에서 3배 이상의 거리이거나, OR 작은 엉덩이 너비가 가장 큰 엉덩이 너비의 75% 이상인 경우:**
    - 겹치거나 충돌이 발생하지 않도록 가능한 한 많은 다리를 추가합니다.
        - If 몸이 튜브에 가까운 경우, 다리를 최대한 많이 추가합니다. (큰 다리를 가진 생물은 두 쌍 이상의 다리를 가질 수 있습니다.)
        - If 몸이 길지만 지면에 가까운 경우, 다리는 작게 설정하고 많은 다리를 추가해야 합니다. 이 경우 지지대를 위해 다리를 많이 추가해야 합니다.
- **Else:**
    - 가장 넓은 지점에 다리를 추가합니다.
    - 기존 다리와 겹치지 않는 다음으로 넓은 뼈를 찾습니다.
        - If 다음 넓은 지점이 원래 가장 넓은 지점의 75% 이상인 경우:
            - 두 번째 넓은 지점에 다리를 추가합니다.
                - If 두 번째로 넓은 겹치지 않는 지점이 첫 번째 지점과 유사한 크기라면, 그곳은 다리를 추가하기 좋은 지점입니다. 이 지점은 다른 다리들과 충분히 떨어져 있어 균형을 잡기에 적합할 것입니다.
        - Else:
            - If 다리가 이미 붙어있는 큰 지점이 중심에 위치하고 있다면 (±2개의 뼈):
                - 다리 한 쌍만 유지합니다. (티라노사우루스 스타일)
            - Else
                - 현재 다리의 반대편에서 가장 가까운 사용 가능한 뼈를 찾아 그곳에 다리를 추가합니다. (균형을 맞추기 위함)

첫 번째 다리 쌍이 머리와 얼마나 가까운지에 따라 팔을 추가할지 여부를 무작위로 결정하는 의사코드
- **If 팔을 추가하는 경우**:
	- 머리와 첫 번째 사용 불가능한 소켓 사이의 중간에 팔을 추가합니다.

한계
- 크리처의 앞이나 뒤에 매우 큰 다리 한 쌍을 추가하면 사용 가능한 모든 슬롯이 겹칠 수 있습니다. 이렇게 하면 다리를 추가하여 수정할 여유 공간이 없어 크리처의 균형이 맞지 않을 수 있습니다.
- 척추가 구부러져 크리처의 가장 두꺼운 부분이 지면과 매우 가까워지면 매우 작은 다리가 부착될 수 있습니다(다리 크기는 부착 지점과 지면 사이의 거리에 따라 결정됩니다)
- 다리가 추가되면 알고리즘은 다리가 걷는 동안 겹치는 뼈를 찾아서 사용할 수 없는 것으로 표시합니다. 그러나 다리를 추가할 때 다리의 크기는 고려하지 않고 단순히 어떤 뼈를 사용할 수 있는지 없는지만 고려합니다. 즉, 아주 작은 다리 한 쌍을 추가하면 양쪽의 작은 수의 뼈만 사용할 수 없는 것으로 표시합니다. 큰 쌍은 작은 다리 옆에 있는 첫 번째 사용 가능한 뼈에 추가되어 겹칠 수 있습니다.

## 4-3. Animation
### 4-3-1. Flying Creatures
비교적 간단한 타입
- Idle 상태일때 공중에서 위아래로 움직임
- 몸의 중간부터 꼬리 끝까지 몇 개의 뼈마다 댐핑 트랜스폼 적용
- 나머지는 회전방향으로 구부러짐
### 4-3-2. Swimming Creature
가장 간단한 타입
- 머리부터 꼬리까지 모든 뼈에 댐핑 트랜스폼 적용
- 머리를 앞뒤로 움직이기만 하면 물결치는 동작이 몸 전체에 전파
- Idle 상태에서는 약간 흔들리도록
### 4-3-3. Walking Creatures
- Idle 상태에선 Root본이 천천히 위아래로 움직여 호흡을 연상시키도록 함
	- 움직임 양은 생물 크기에 따라서 수정
- 회전 시 꼬리를 회전방향으로 구부린다
	- 회전량은 뼈의 수에 따라 결정
- 각 다리에는 발 위치를 지시하는 타겟이 있음.
	- 타겟의 위치는 'targetMove' 스크립트에 의해 구동
	- 각 프레임마다 본에서 바닥을 향해 Ray 발사
	- 발 위치와 Ray가 닿은 지점 사이의 거리가 충분히 크면 몸 앞에 새로운 스텝 위치를 계산. 
		- 스텝 위치의 거리는 스텝 크기 파라미터로 결정 
- 걸음걸이 규칙
	- 일반적으로 대각선에 위치한 발이 동시에 움직이는 방식을 적용
	- 다양한 걸음걸이가 적용되지 못한 구현의 한계가 존재함
	- 다리가 여러 쌍일때 (1쌍이상)
		- 모든 다리가 한쪽에서 동시에 움직이려고 함
		- 왼쪽 다리의 움직임이 이전에 추가된 왼쪽 다리의 움직임에 의해 제어되도록 한다.
	- 발 위치를 이전 위치와 새로운 위치 사이에서 선형 보간으로 계산
	- 발이 들리는 중간지점에서는 sin 함수로 발이 올라가는 효과를 줌
	- 발이 목표 위치에 도달할 때까지 거리에 따라 움직임이 자동으로 조정되도록 함
	- 생물이 중간에 멈출 경우 발이 바닥에 닿도록 함
- 엉덩이의 회전
	- 발에 따라 척추 뼈에 회전 적용
- 한가지 걷는 스타일만을 표현하는데에 그친 점이 한계

# 5. Conclusion
- 일반적인 보행 스타일만 구현한다는 점이 가장 큰 한계점이었음
- 다만 이런식으로 일반화 했을 때 얻는 이점이 크다
- 기본 바디 생성을 셰이더 연산으로 전환하여 성능을 향상시킬 수 있었는데 시간관계상 못했다
- 팔다리 이의 뿔, 껍질, 액세서리 등 추가할 사항들이 더 있다.
- 캥거루 스타일로 뛰거나, 고양이처럼 달리거나, 다리가 없으면 뱀처럼 기어가거나 하는 다양한 보행 스타일 등 추가할 사항들이 더 있다.
